!SESSION 2021-06-04 09:14:22.280 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\User\eclipse-workspace\.metadata\.bak_0.log
Created Time: 2021-06-04 15:04:58.790

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:04:58.790
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:04:58.791
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:02.788
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;

		#include "board.cpp"
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */
		class player{
		public:
		    void wargamesReference();
		};

		void player::wargamesReference()
		{
		    int jokes;
		    std::cout << "Would you like to play a game? \n";
			std::cout << "1. Konane \n2. ALSO Konane\n3. Global Thermonuclear War (Obligatory Wargames Reference)\n";
			std::cin >> jokes;
			if (jokes == 3) {
				std::cout << "That game is SOOOOOOOO boring,let's play Konane!!!\n";
			}
		}


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:05:02.789
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:05:02.789
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:02.820
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;

		#include "board.cpp"
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */
		class player{
		public:
		    void wargamesReference();
		};

		void player::wargamesReference()
		{
		    int jokes;
		    std::cout << "Would you like to play a game? \n";
			std::cout << "1. Konane \n2. ALSO Konane\n3. Global Thermonuclear War (Obligatory Wargames Reference)\n";
			std::cin >> jokes;
			if (jokes == 3) {
				std::cout << "That game is SOOOOOOOO boring,let's play Konane!!!\n";
			}
		}


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:05:02.821
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:05:02.822
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:06.122
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;

		#include "board.cpp"
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */
		class player{
		public:
		    void wargamesReference();
		};

		void player::wargamesReference()
		{
		    int jokes;
		    std::cout << "Would you like to play a game? \n";
			std::cout << "1. Konane \n2. ALSO Konane\n3. Global Thermonuclear War (Obligatory Wargames Reference)\n";
			std::cin >> jokes;
			if (jokes == 3) {
				std::cout << "That game is SOOOOOOOO boring,let's play Konane!!!\n";
			}
		}


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:05:06.122
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:05:06.123
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:08.353
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */
		class player{
		public:
		    void wargamesReference();
		};

		void player::wargamesReference()
		{
		    int jokes;
		    std::cout << "Would you like to play a game? \n";
			std::cout << "1. Konane \n2. ALSO Konane\n3. Global Thermonuclear War (Obligatory Wargames Reference)\n";
			std::cin >> jokes;
			if (jokes == 3) {
				std::cout << "That game is SOOOOOOOO boring,let's play Konane!!!\n";
			}
		}


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:05:08.354
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:05:08.354
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:08.913
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */
		class player{
		public:
		    void wargamesReference();
		};

		void player::wargamesReference()
		{
		    int jokes;
		    std::cout << "Would you like to play a game? \n";
			std::cout << "1. Konane \n2. ALSO Konane\n3. Global Thermonuclear War (Obligatory Wargames Reference)\n";
			std::cin >> jokes;
			if (jokes == 3) {
				std::cout << "That game is SOOOOOOOO boring,let's play Konane!!!\n";
			}
		}


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:05:08.915
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:05:08.915
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:09.355
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */
		class player{
		public:
		    void wargamesReference();
		};

		void player::wargamesReference()
		{
		    int jokes;
		    std::cout << "Would you like to play a game? \n";
			std::cout << "1. Konane \n2. ALSO Konane\n3. Global Thermonuclear War (Obligatory Wargames Reference)\n";
			std::cin >> jokes;
			if (jokes == 3) {
				std::cout << "That game is SOOOOOOOO boring,let's play Konane!!!\n";
			}
		}


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:05:09.356
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:05:09.357
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:13.134
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */
		class player{
		public:
		    void wargamesReference();
		};

		void player::wargamesReference()
		{
		    int jokes;
		    std::cout << "Would you like to play a game? \n";
			std::cout << "1. Konane \n2. ALSO Konane\n3. Global Thermonuclear War (Obligatory Wargames Reference)\n";
			std::cin >> jokes;
			if (jokes == 3) {
				std::cout << "That game is SOOOOOOOO boring,let's play Konane!!!\n";
			}
		}


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:05:13.135
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:05:13.135
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:15.891
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:05:15.892
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:05:15.892
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:15.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:05:15.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:05:15.923
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:21.164
!MESSAGE JavaBuilder handling CoreException while building: KonaneJava
!STACK 1
org.eclipse.core.runtime.CoreException: release 15 is not found in the system
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.initialize(ClasspathJrtWithReleaseOption.java:120)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:82)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:146)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.computeClasspathLocations(NameEnvironment.java:313)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.<init>(NameEnvironment.java:62)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.initializeBuilder(JavaBuilder.java:643)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:181)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.IllegalArgumentException: release 15 is not found in the system
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.initialize(ClasspathJrtWithReleaseOption.java:119)
	... 18 more
!SUBENTRY 1 org.eclipse.jdt.core 4 0 2021-06-04 15:05:21.164
!MESSAGE release 15 is not found in the system
!STACK 0
java.lang.IllegalArgumentException: release 15 is not found in the system
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.initialize(ClasspathJrtWithReleaseOption.java:119)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:82)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:146)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.computeClasspathLocations(NameEnvironment.java:313)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.<init>(NameEnvironment.java:62)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.initializeBuilder(JavaBuilder.java:643)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:181)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:05:21.924
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:05:21.925
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:05:21.926
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:06:37.284
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:06:37.285
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:06:37.285
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:06:37.321
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:06:37.322
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:06:37.322
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:08:12.100
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:08:12.101
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:08:12.101
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:08:14.130
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:08:14.130
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:08:14.131
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:08:53.628
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:08:53.630
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:08:53.630
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:08:54.178
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){

		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:08:54.179
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:08:54.180
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:08:57.703
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){
			
		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:08:57.703
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:08:57.704
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:08:57.743
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){
			
		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:08:57.744
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:08:57.745
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:08:58.729
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

public class Konane {

	public static void main(String[] args) {
		/*Order of Game Play*/
		/*Game is lost when there are no longer any valid moves.*/
				/* 1. determine who plays Black and is thus first.
				 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
				 *
				 *     **GAME LOOP**    *
				 * 3. wait for input or make input
				 * 4. upon AI move:

				 * run legalmove on each position in array when is turn (and board is accurate.)
				 * N,S,E,W determines legalmove direction.
				 *
				 * the following bounds due to no move possible:
				 * if i<2 (row) don't run N
				 * if i>5 don't run S,
				 *
				 * if j<2 (column) don't run W,
				 * if j>5 don't run E.
				 *
				 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
				 * evaluate the Southernmost... etc
				 * ******************* RECURSIVE CALLS  ***************************
				 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
				 * it is a DFS.
				 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
				 * WITHOUT any data loss.
				 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
				 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
				 *
				 **************	State Evaluation function (SEF)*********************
				 *
				 * 7. The SEF evaluates partly by counting legal moves for player in that state.
				 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
				 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
				 *
				 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
				 * will take up the largest values
				 *
				 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
				 */


		/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


		/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

		/**color is AI, humanColor is opponent**/

		/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
		int AIcolor, humanColor;
		/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
		/***(setters and getters, removed from code at this time)***/
		/*int getFirst(){return first;}
		 *int getColor() {return AIcolor;}
		 *int getPlayerColor() {return playerColor;}
		 */


		void write_csv(double input[], int totalMoves){
			
		    // Make a CSV file with move record for stat tracking
		    // Each column of data is represented by the pair <column name, column data>

		    std::ofstream csv("parallel-moves-14-1.csv");
		    csv<<"Turn, Time \n";
		    for(int i=0;i<totalMoves;i++){
		        csv<<i+1<<","<<input[i]<<"\n";
		    }


		    // Close the file
		    csv.close();
		}



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:08:58.730
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:08:58.730
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.ui.ide 4 4 2021-06-04 15:11:06.162
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.swt.dnd.TreeDragSourceEffect.getDragSourceImage(TreeDragSourceEffect.java:149)
	at org.eclipse.swt.dnd.TreeDragSourceEffect.dragStart(TreeDragSourceEffect.java:81)
	at org.eclipse.swt.dnd.DNDListener.handleEvent(DNDListener.java:36)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.dnd.DragSource.drag(DragSource.java:475)
	at org.eclipse.swt.dnd.DragSource.lambda$0(DragSource.java:380)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.dialogs.PropertyDialogAction.run(PropertyDialogAction.java:153)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:14:19.484
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

import java.io.FileWriter;

public class Konane {
	/*Order of Game Play*/
	/*Game is lost when there are no longer any valid moves.*/
			/* 1. determine who plays Black and is thus first.
			 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
			 *
			 *     **GAME LOOP**    *
			 * 3. wait for input or make input
			 * 4. upon AI move:

			 * run legalmove on each position in array when is turn (and board is accurate.)
			 * N,S,E,W determines legalmove direction.
			 *
			 * the following bounds due to no move possible:
			 * if i<2 (row) don't run N
			 * if i>5 don't run S,
			 *
			 * if j<2 (column) don't run W,
			 * if j>5 don't run E.
			 *
			 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
			 * evaluate the Southernmost... etc
			 * ******************* RECURSIVE CALLS  ***************************
			 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
			 * it is a DFS.
			 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
			 * WITHOUT any data loss.
			 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
			 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
			 *
			 **************	State Evaluation function (SEF)*********************
			 *
			 * 7. The SEF evaluates partly by counting legal moves for player in that state.
			 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
			 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
			 *
			 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
			 * will take up the largest values
			 *
			 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
			 */


	/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


	/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

	/**color is AI, humanColor is opponent**/

	/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
	int AIcolor, humanColor;
	/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
	/***(setters and getters, removed from code at this time)***/
	/*int getFirst(){return first;}
	 *int getColor() {return AIcolor;}
	 *int getPlayerColor() {return playerColor;}
	 */


	void write_csv(double[] input, int totalMoves){
		FileWriter csv = new FileWriter("parallel-moves-14-1.csv");
			
	    // Make a CSV file with move record for stat tracking
	    // Each column of data is represented by the pair <column name, column data>

	    csv.write("Turn, Time \n");
	    for(int i=0;i<totalMoves;i++){
	    	csv.write/9   csv<<i+1<<","<<input[i]<<"\n";
	    }


	    // Close the file
	    csv.close();
	}

	public static void main(String[] args) {



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-04 15:14:19.485
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-04 15:14:19.485
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-06-04 15:14:19.514
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.konane.java;

import java.io.FileWriter;

public class Konane {
	/*Order of Game Play*/
	/*Game is lost when there are no longer any valid moves.*/
			/* 1. determine who plays Black and is thus first.
			 * 2. choose to remove 2 pieces if not first (another variant has the removal of one piece by each player).
			 *
			 *     **GAME LOOP**    *
			 * 3. wait for input or make input
			 * 4. upon AI move:

			 * run legalmove on each position in array when is turn (and board is accurate.)
			 * N,S,E,W determines legalmove direction.
			 *
			 * the following bounds due to no move possible:
			 * if i<2 (row) don't run N
			 * if i>5 don't run S,
			 *
			 * if j<2 (column) don't run W,
			 * if j>5 don't run E.
			 *
			 * so the first square in a column doesn't evaluate the Northern most move and the last square will not
			 * evaluate the Southernmost... etc
			 * ******************* RECURSIVE CALLS  ***************************
			 * 5. if legalmove returns true, form node (recursive call with new board) with move and repeat process board to obtain number.
			 * it is a DFS.
			 * 6. the calls eventually reach depth d and the SEF is run.  It is notable that the alpha and beta cutoffs will reduce the number of boards evaluated
			 * WITHOUT any data loss.
			 * (this is a less intuitive action of the recursive function, no data is lost, but branches that the AI will NEVER select are not explored further.
			 * essentially, a node which comes out too high or too low relative to the node examined will not be selected)
			 *
			 **************	State Evaluation function (SEF)*********************
			 *
			 * 7. The SEF evaluates partly by counting legal moves for player in that state.
			 * Additionally, it counts pieces and estimates based on expected piece balance (each move must remove one piece, if more pieces are missing a
			 * double move has occurred.  The SEF assumes that this is bad for the player who had this happen to it.)
			 *
			 * The SEF value is passed up to the top of the tree with varied modifications, minimizing levels take the lowest value to pass, maximizing
			 * will take up the largest values
			 *
			 * Dir can = 0 for N (up), 1 for E(right), 2 for S (down), 3 for W (left)
			 */


	/**REMEMBER TO USE THE DIAGNOSTIC PRINTOUTS FOR FUTURE CHANGES**/


	/**FUNCTIONAL WITH 16 DEPTH, EASE OF TESTING AT 14 OR 12 DEPTH, GAMEPLAY IS DIFFERENT DEPENDING ON DEPTH**/

	/**color is AI, humanColor is opponent**/

	/***MUST HAVE THESE GLOBALS, COULD PERHAPS EDIT INTO BOARD?***/
	int AIcolor, humanColor;
	/******************DUE TO FOLLOWING OFFICIAL RULES, COLOR HAS BEEN MERGED WITH FIRST**********************/
	/***(setters and getters, removed from code at this time)***/
	/*int getFirst(){return first;}
	 *int getColor() {return AIcolor;}
	 *int getPlayerColor() {return playerColor;}
	 */


	void write_csv(double[] input, int totalMoves){
		FileWriter csv = new FileWriter("parallel-moves-14-1.csv");
			
	    // Make a CSV file with move record for stat tracking
	    // Each column of data is represented by the pair <column name, column data>

	    csv.write("Turn, Time \n");
	    for(int i=0;i<totalMoves;i++){
	    	csv.write/9   csv<<i+1<<","<<input[i]<<"\n";
	    }


	    // Close the file
	    csv.close();
	}

	public static void main(String[] args) {



		/**TODO:: TOO MUCH IN MAIN!! REFACTOR!!**/

		int main() {
			int Dir = 0;
			int level=0;
			int turn=0;
			int i,j,k,m,z, alpha, beta, state;
			double tc;
			//for recording time
		    double csv[50];
		    duration<double> timeCount;

		    //who is first, whose turn is it, is it zero player,is the human player making a legal move?
			bool first, AIturn, ZeroPlay, legalHumMove;
			//objects
			player player;
			board board, board1, board2, board3, board4, board5, board6, board7, board8;
			/**odd numbered depths end on min nodes, even on max. This doesn't work. This is to check for that**/
			std::cout<<"depth = "<< depth<<". (This should be an even number)\n";
			std::cout<<"\n";

			player.wargamesReference();
			//Zero Player Game?
			ZeroPlay=board.setZpgame();
			if (right){
		        board.zpgame=true;
			}
			//Who is black, goes first?
			first=board.setColor();
			if (first == true) {
				AIturn = true;
			}
			else{
		        AIturn=false;
			}
			/**SETS BOARD UP**/
		    board.manualOverride();
		    //Starts the clock.
		    high_resolution_clock::time_point t1 = high_resolution_clock::now();
			while (true) {
		            //if all moves lose.

		        if(board.bval<-500){
		            std::cout<<"Game over, White loses";
		            break;
		                }
				if (AIturn) {
		            /**This should be refactored into a function.
		            *This initializes every board object to the same state, starts the clock on the move and
		            *makes the **/



		            high_resolution_clock::time_point tpre = high_resolution_clock::now();
		            board1=board;
		            board2=board;
		            board3=board;
		            board4=board;
		            board5=board;
		            board6=board;
		            board7=board;
		            board8=board;
		            //Initiates threads, calls them on the rows of the board
		            //Alpha and Beta NOT set to Min and Max at first call.  This has improved efficiency and reduced error.
		            //They ARE set to MAX and MIN later.
					thread th1( &board::threadKonane, &board1, 0, 1,2,depth,AIcolor);
					thread th2( &board::threadKonane, &board2, 1, 1,2,depth,AIcolor);
					thread th3( &board::threadKonane, &board3, 2, 1,2,depth,AIcolor);
					thread th4( &board::threadKonane, &board4, 3, 1,2,depth,AIcolor);
					thread th5( &board::threadKonane, &board5, 4, 1,2,depth,AIcolor);
					thread th6( &board::threadKonane, &board6, 5, 1,2,depth,AIcolor);
					thread th7( &board::threadKonane, &board7, 6, 1,2,depth,AIcolor);
					thread th8( &board::threadKonane, &board8, 7, 1,2,depth,AIcolor);

					//Joins threads to main program after program run (some efficiencies to realize here).
					th1.join();
					th2.join();
					th3.join();
					th4.join();
					th5.join();
					th6.join();
					th7.join();
					th8.join();
					//makes a comparison between the 8 boards and selects the ideal board from them
		            board = board.comparison(board1, board2, board3, board4, board5, board6, board7, board8);
		            //displays prior board
					board.display();
					//if no valid moves
		            if(board.bval<-500){
		                cout<<"Game Over, Black Loses";
		                break;
		                }

		            //Uses the "bestmove" array to make the move chosen by algorithim
		            board.makeMove(board.bestmove, AIcolor);
		            //displays the move in start i, start j, destination i, destination j, format.
		            board.displayMove();
		            //displays the board
					board.display();

					//Passes turn
					AIturn = false;
					//increments turn counter
					turn++;
					//stops clock and counts value
					high_resolution_clock::time_point tpost = high_resolution_clock::now();
					timeCount = duration_cast<duration<double>>(tpost-tpre);
		            tc=timeCount.count();
		            //gives amount of time taken
		            std::cout<<"\n"<<tc<<"\n";
		            //records time and turn to array
		            csv[turn-1]=tc;
		            }
		            /** if PLAYING AGAINST ITSELF OR A SIMILAR AI W A DIFFERENT SEF**/
		            //same as above
		            if((ZeroPlay) && (AIturn==false)){

		                high_resolution_clock::time_point tpre = high_resolution_clock::now();
		                board1=board;
		                board2=board;
		                board3=board;
		                board4=board;
		                board5=board;
		                board6=board;
		                board7=board;
		                board8=board;
		                thread th1( &board::threadKonane, &board1, 0, 1,2,depth,humanColor);
		                thread th2( &board::threadKonane, &board2, 1, 1,2,depth,humanColor);
		                thread th3( &board::threadKonane, &board3, 2, 1,2,depth,humanColor);
		                thread th4( &board::threadKonane, &board4, 3, 1,2,depth,humanColor);
		                thread th5( &board::threadKonane, &board5, 4, 1,2,depth,humanColor);
		                thread th6( &board::threadKonane, &board6, 5, 1,2,depth,humanColor);
		                thread th7( &board::threadKonane, &board7, 6, 1,2,depth,humanColor);
		                thread th8( &board::threadKonane, &board8, 7, 1,2,depth,humanColor);
		                th1.join();
		                th2.join();
		                th3.join();
		                th4.join();
		                th5.join();
		                th6.join();
		                th7.join();
		                th8.join();
		                board = board.comparison (board1, board2, board3, board4, board5, board6, board7, board8);
		                board.display();
		                //if no valid moves
		                if(board.bval<-500){
		                std::cout<<"Game over, White loses";
		                break;
		                }
		                board.makeMove(board.bestmove, humanColor);
		                board.displayMove();

		                board.display();


		                AIturn = true;
		                turn++;
		                //record timing.
		                high_resolution_clock::time_point tpost = high_resolution_clock::now();
		                timeCount = duration_cast<duration<double>>(tpost-tpre);
		                tc=timeCount.count();
		                std::cout<<"\n"<<tc<<"\n";
		                csv[turn-1]=tc;
		                }
		            /** if PLAYING A HUMAN**/
				if((!ZeroPlay) && (AIturn==false)) {
		            do{
		                std::cout << "\nenter piece to move column, 1-8: ";
		                //source column
		                std::cin >> j;
		                //accomodate indexing
		                j--;
		                //enters player move into array
		                board.bestmove[1]=j;
		                std::cout << "\nenter piece to move row, 1-8: ";
		                std::cin >> i;
		                i--;
		                //source row
		                board.bestmove[0]=i;
		                std::cout << "\nenter piece destination column, 1-8: ";
		                std::cin >> m;
		                m--;
		                //destination column
		                board.bestmove[3]=m;
		                std::cout << "\nenter piece destination row, 1-8: ";
		                std::cin >> k;
		                k--;
		                //destination row
		                board.bestmove[2]=k;
		                legalHumMove=board.guardRails();
		            }while(! legalHumMove);
		            //is this move legal?


					board.makeMove(board.bestmove,humanColor);
					board.displayMove();
					board.display();
					turn++;
					AIturn=true;
					}
		        std::cout<<  "\nassuming correct board and continue\n";
			}
			high_resolution_clock::time_point t2 = high_resolution_clock::now();
			 duration<double> time_span = duration_cast<duration<double>>(t2 - t1);
			std::cout<<"finished in "<<turn<<" turns";
		    std::cout << "It took me " << time_span.count() << " seconds.\n";
		    for(z=0;z<turn;z++)
		        {std::cout<<"turn " <<z+1<< " took "<<csv[z]<<" seconds \n";}
		    //write_csv(csv, turn);
			return 0;
		}



	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-06-04 15:14:19.515
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-06-04 15:14:19.515
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-06-07 10:03:55.138 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-07 10:04:02.012
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-07 10:04:02.012
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47eae91d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c1a74d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-07 10:04:08.960
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-07 15:02:13.135 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-07 15:02:19.046
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-07 15:02:19.047
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e993715,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@686e7513,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-07 15:02:25.453
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-08 09:06:18.287 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-08 09:06:25.212
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-08 09:06:25.212
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@270b8c2a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7b9c2387,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-08 09:06:31.591
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-08 11:29:35.016 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-08 11:29:41.905
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-08 11:29:41.905
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2aa07d80,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c1ea07,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-08 11:29:47.852
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-09 10:52:21.689 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-09 10:52:28.116
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-09 10:52:28.116
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5cbe72b9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@27fc0217,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-09 10:52:34.860
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-10 10:06:24.086 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-10 10:06:36.304
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-10 10:06:36.304
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25df2014,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@270b8c2a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-10 10:06:47.434
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-10 11:09:58.702 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-10 11:10:04.262
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-10 11:10:04.262
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c1a74d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@472719df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-10 11:10:10.670
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-10 14:17:01.852 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-10 14:17:07.923
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-10 14:17:07.923
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c1a74d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@472719df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-10 14:17:14.448
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-11 11:03:08.417 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-11 11:03:14.487
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-11 11:03:14.487
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2aa07d80,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c1ea07,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-11 11:03:20.145
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-14 09:45:46.198 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-14 09:46:01.408
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-14 09:46:01.408
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@686e7513,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47eae91d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-14 09:46:08.188
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-14 12:20:22.447 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-14 12:20:28.860
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-14 12:20:28.860
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@27fc0217,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e993715,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-14 12:20:35.222
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-15 11:08:54.054 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-15 11:09:39.676
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-15 11:09:39.676
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2fea9a7b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2aa07d80,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-15 11:09:46.288
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-17 10:23:33.752 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-17 10:23:40.523
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-17 10:23:40.524
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@413eaf5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e28af44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-17 10:23:47.165
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.workbench 4 2 2021-06-17 10:29:00.905
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:534)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:237)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:266)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:178)
	at org.eclipse.ui.internal.WorkbenchWindow$WWinPartService.partActivated(WorkbenchWindow.java:3163)
	at org.eclipse.ui.internal.WorkbenchPage$3.run(WorkbenchPage.java:4892)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.WorkbenchPage.firePartActivated(WorkbenchPage.java:4889)
	at org.eclipse.ui.internal.WorkbenchPage$E4PartListener.partActivated(WorkbenchPage.java:219)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl$2.run(PartServiceImpl.java:249)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.firePartActivated(PartServiceImpl.java:246)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:770)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.setPart(PartServiceImpl.java:217)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:990)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:963)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:942)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:897)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2087)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1719)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1716)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1752)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:578)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4861)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4861)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
!SESSION 2021-06-17 10:29:11.824 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-17 10:29:19.076
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-17 10:29:19.076
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4583b617,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22a63740,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-17 10:29:24.421
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-17 14:30:52.929 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-17 14:30:59.595
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-17 14:30:59.595
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c97f5e9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32e7b78d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-17 14:31:05.029
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-17 15:46:45.179 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-17 15:46:52.016
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-17 15:46:52.016
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@602a3237,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b511e61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-17 15:46:54.928
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-17 15:54:05.931 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-17 15:54:12.217
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-17 15:54:12.217
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22ff11ef,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c5ac0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-17 15:54:15.032
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-18 09:13:14.769 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-18 09:13:22.185
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-18 09:13:22.185
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5cfa2ac5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cc89246,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-18 09:13:28.167
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-18 12:04:33.363 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-18 12:04:39.948
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-18 12:04:39.948
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5a78b52b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4bab78ce,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-18 12:04:45.968
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-18 12:09:35.590 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product C:\Users\User\eclipse-workspace\KonaneJava\src\com\konane\java\Konane.java
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product C:\Users\User\eclipse-workspace\KonaneJava\src\com\konane\java\Konane.java

!ENTRY org.eclipse.jface 2 0 2021-06-18 12:09:41.426
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-18 12:09:41.426
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@a63643e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@43294e9b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-18 12:09:47.068
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-18 12:10:08.288 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product C:\Users\User\eclipse-workspace\KonaneJava\src\com\konane\java\Konane.java
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product C:\Users\User\eclipse-workspace\KonaneJava\src\com\konane\java\Konane.java

!ENTRY org.eclipse.jface 2 0 2021-06-18 12:10:13.901
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-18 12:10:13.901
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@33891646,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bdbf8d3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-18 12:10:19.532
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-18 14:52:32.720 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-18 14:52:38.523
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-18 14:52:38.523
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@413eaf5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e28af44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-18 14:52:45.112
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-21 10:40:00.232 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-21 10:40:08.062
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-21 10:40:08.062
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@27fc0217,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e993715,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-21 10:40:15.252
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-22 14:36:14.984 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-22 14:36:21.589
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-22 14:36:21.590
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@413eaf5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e28af44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-22 14:36:28.426
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-22 15:51:35.429 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-22 15:51:41.524
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-22 15:51:41.524
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@472719df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5cfa2ac5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-22 15:51:46.539
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-22 17:11:45.538 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-22 17:11:52.273
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-22 17:11:52.273
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cc89246,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@413eaf5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-22 17:11:59.131
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
